= Building an Asteroids Clone with Gosu

Using Ruby, Gosu, and pure awesomeness, we're going to build a clone of Atari's 1979 classic, Asteroids.

This guide assumes that you're using OSX but should be approximately the same for Linux/Windows. If you're having trouble getting Gosu installed on your box, that's okay, we can pair up on machines that have a working install. TEAMWORK! :)

== Install Gosu

Follow the instructions for RUBY here:

  http://code.google.com/p/gosu/wiki/GettingStartedOnOsx
  http://code.google.com/p/gosu/wiki/GettingStartedOnLinux
  http://code.google.com/p/gosu/wiki/GettingStartedOnWindows

== Test Gosu Installation

Create a folder for your project:

  mkdir asteroids
  cd asteroids
  mkdir lib

Copy the gosu bundle to your project:

  cp /opt/local/lib/ruby/gems/1.8/gems/gosu-0.7.23-universal-darwin/lib/gosu.for_1_8.bundle lib 

Create the initial file for your game:

  touch game.rb

Make it executable

  chmod +x game.rb

Edit game.rb to inclue the following:

  #!/usr/bin/env ruby -w

  require 'lib/gosu.for_1_8.bundle'

  class GameWindow < Gosu::Window
    def initialize
      super(640, 480, false)
    end
  end

  window = GameWindow.new
  window.show

Calling 'super' in the 'initialize' method sets the display resolution and if it's run in fullscreen or windowed mode.

Run the file:

  ./game.rb

You should see a blank window. If you do, you're ready to go!

== Gosu Callbacks (Game Loop)

There are two main loops in Gosu that will provide you with the constructs in which to build a game.

The first is the 'update' method. This method is called 60 times a second and is where you handle your standard game logic. This is considered the game loop.

The second is the 'draw' method. This is called after each 'update' iteration and is used to 'draw' the changes on screen. It's recommended that you avoid putting logic in this method. It should only be used to draw to the screen resulting from changes in state made during the update loop.

These loops will run forever until you quit the application.

Add these two methods to your main game file:

  # 60 times per second
  def update
  end

  # happens immediately after each iteration of the update method
  def draw
  end

You can see how fast these loops run if you put a 'puts' statement in the update method. Keep in mind that you're not seeing 60 'puts' a second. You're terminal may not be able to keep up and will degrade game performance. 

== Images (background)

Images are the primary way we'll be displaying information on screen throughout this application. 

The first most basic image is a background image. 

  class GameWindow < Gosu::Window
    def initialize
      @background_image = Gosu::Image.new(self, "assets/background.png", true)
    end
  end

You'll notice that Gosu::Image takes a few arguments:

  The first is the window to which the image belongs
  The second is the path to the image
  The last is if the image is tileable 

The constructor (from the docs):

  # initialize(window, filename_or_rmagick_image, tileable, [srcX, srcY, srcWidth, srcHeight]) 

Once you have the image stored in an instance variable, you'll need to actually display/draw it to the game window:

  class GameWindow < Gosu::Window
    def draw
      @background_image.draw(0, 0, 0)   
    end  
  end

Draw takes a few arguments, we're using x, y, and z coordinates.

It's important to note that the game window uses Cartesian coordinates. This is how you will place objects in the window.

== Handling Input

See the documentation for a list of all possible input triggers:

  http://code.google.com/p/gosu/wiki/RubyReference

  if button_down? Gosu::KbH
    puts 'pressing' if id == Gosu::KbH
  end

This will print 'pressing' the whole time the 'h' key is being pressed, or held down.

There is also a method called 'button_down(id)' which is called once per key press.

  def button_down(id)
    puts 'pressed' if id == Gosu::KbH
  end

This will print 'pressed' once, even if the 'h' key is held down on the keyboard. This resets once the button has been released.

A useful test for this is to create a button that will allow you to quit the game easily. Gosu provides the 'close' method for this very purpose. 

=Lab_01

* Experiment with different resolution sizes (fullscreen vs. windowed)
* Set a background image and experiment with it's positioning
* Setup and manually test the game loop (update)
* Map a key to close the application

== The Player, drawing

Now that we have a basic understanding of the game window, let's move onto something a bit more fun and interactive: The player. This is the ship that the player controls.

The first thing we need to do is create a file where the player's source can exist:

  touch lib/player.rb

And include it in the main game file game.rb:

  require 'lib/player'

Open lib/player.rb and create a basic class:

  class Player
    def initialize(window)
    end
  end

You'll notice that we're requiring that the window be passed to the player upon creation -- this is because you'll need that window object in order to setup the player's image (the ship). The image needs to know where it will be drawn.

Let's setup the image just like we did with the background image:

  class Player
    def initialize(window)
      @image = Gosu::Image.new(window, 'assets/ship.png', false)
    end
  end
  
We also need to make it so we can draw the player to the screen:

  class Player
    def draw
      @image.draw_rot(320, 240, 0, 0)
    end
  end

Notice that we're using 'draw_rot' instead of 'draw'. This will become important shortly, this will allow us to rotate the image instead of having it in a fixed position.

The arguments are: draw_rot(x,y,z,angle)

We're drawing the player ship in the middle of our screen (640x480) with no z-index and no angle.

We'll then need to setup a player in the actual game itself:
  
  require 'lib/player'

  class GameWindow < Gosu::Window
    def initialize
      @player = Player.new(self)
    end

    def draw
      @player.draw
    end
  end

This will instantiate a new player object and will draw it on screen.

== The Player, turning

Now that we can display the player on screen, we can work on controlling it with keyboard input.

Let's start with turning. First let's capture some input:

  class GameWindow < Gosu::Window
    def update
      control_player
    end

    def control_player
      if button_down? Gosu::KbLeft
        puts 'turning left'
      end
      if button_down? Gosu::KbRight
        puts 'turning right'
      end
    end
  end
  
This should print the debug messages any time you hold down left or right.

Now we'll wire this up to the actual Player:

  class Player
    def initialize(window)
      @angle = 0.0
    end

    def turn_left
      @angle -= 4.5
    end

    def turn_right
      @angle += 4.5
    end
  end 

And then replace the debug message:

  class GameWindow < Gosu::Window
    def control_player
      if button_down? Gosu::KbLeft
        @player.turn_left
      end
      if button_down? Gosu::KbRight
        @player.turn_right
      end
    end
  end

This might be kind of slow -- due to the debug messages in the update loop, time to remove/comment this line:
  
  class GameWindow < Gosu::Window
    def update
      # puts 'testing game loop...'
    end
  end

= Lab_02

== The Player, acceleration

The next thing we need to do is handle acceleration... and first, lets capture the input of the Up arrow:

  class GameWindow < Gosu::Window
    def control_player
      if button_down? Gosu::KbUp
        @player.accelerate
      end
    end
  end

And wire it up in the Player... we'll need to add a few things here...

First, we'll need some way to keep track of the player's velocity:

  class Player
    def initialize(window)
      @velocity_x = @velocity_y = @angle = 0.0
    end
  end
  

