= Building an Asteroids Clone with Gosu

Using Ruby, Gosu, and pure awesomeness, we're going to build a clone of Atari's 1979 classic, Asteroids.

This guide assumes that you're using OSX but should be approximately the same for Linux/Windows.

== Install Gosu

Follow the instructions for RUBY here:

  http://code.google.com/p/gosu/wiki/GettingStartedOnOsx
  http://code.google.com/p/gosu/wiki/GettingStartedOnLinux
  http://code.google.com/p/gosu/wiki/GettingStartedOnWindows

== Test Gosu Installation

Create a folder for your project:

  mkdir asteroids
  cd asteroids
  mkdir lib

Copy the gosu bundle to your project:

  cp /opt/local/lib/ruby/gems/1.8/gems/gosu-0.7.23-universal-darwin/lib/gosu.for_1_8.bundle lib 

Create the initial file for your game:

  touch game.rb

Make it executable

  chmod +x game.rb

Edit game.rb to inclue the following:

  #!/usr/bin/env ruby -w

  require 'lib/gosu.for_1_8.bundle'

  class GameWindow < Gosu::Window
    def initialize
      super(640, 480, false)
    end
  end

  window = GameWindow.new
  window.show

Calling 'super' in the 'initialize' method sets the display resolution and if it's run in fullscreen or windowed mode.

Run the file:

  ./game.rb

You should see a blank window. If you do, you're ready to go!

== Gosu Callbacks (Game Loop)

There are two main loops in Gosu that will provide you with the constructs in which to build a game.

The first is the 'update' method. This method is called 60 times a second and is where you handle your standard game logic. This is considered the game loop.

The second is the 'draw' method. This is called after each 'update' iteration and is used to 'draw' the changes on screen. It's recommended that you avoid putting logic in this method. It should only be used to draw to the screen resulting from changes in state made during the update loop.

These loops will run forever until you quit the application.

Add these two methods to your main game file:

  # 60 times per second
  def update
  end

  # happens immediately after each iteration of the update method
  def draw
  end

You can see how fast these loops run if you put a 'puts' statement in the update method. Keep in mind that you're not seeing 60 'puts' a second. You're terminal may not be able to keep up and will degrade game performance. 

== Images (background)

Images are the primary way we'll be displaying information on screen throughout this application. 

The first most basic image is a background image. 

  class GameWindow < Gosu::Window
    def initialize
      @background_image = Gosu::Image.new(self, "assets/background.png", true)
    end
  end

You'll notice that Gosu::Image takes a few arguments:

  The first is the window to which the image belongs
  The second is the path to the image
  The last is if the image is tileable 

The constructor (from the docs):

  # initialize(window, filename_or_rmagick_image, tileable, [srcX, srcY, srcWidth, srcHeight]) 

Once you have the image stored in an instance variable, you'll need to actually display/draw it to the game window:

  class GameWindow < Gosu::Window
    def draw
      @background_image.draw(0, 0, 0)   
    end  
  end

Draw takes a few arguments, we're using x, y, and z coordinates.

It's important to note that the game window uses Cartesian coordinates. This is how you will place objects in the window.

== Handling Input

See the documentation for a list of all possible input triggers:

  http://code.google.com/p/gosu/wiki/RubyReference

  if button_down? Gosu::KbH
    puts 'pressing' if id == Gosu::KbH
  end

This will print 'pressing' the whole time the 'h' key is being pressed, or held down.

There is also a method called 'button_down(id)' which is called once per key press.

  def button_down(id)
    puts 'pressed' if id == Gosu::KbH
  end

This will print 'pressed' once, even if the button is held down. This resets once the button has been released.

A useful test for this is to create a button that will allow you to quit the game easily. Gosu provides the 'close' method for this very purpose. 

=Lab 1

* Experiment with different resolution sizes (fullscreen vs. windowed)
* Set a background image
* Setup and manually test the game loop (update)
* Map a key to close the application

